---
layout: post
title:  "Rust로 컴파일 시점에 피보나치 수열 구하기"
date:   2021-04-21 18:00:00 +0900
---

오늘은 [간단한 피보나치 문제][1]를 Rust의 [컴파일 시점 함수 실행][2] 기능을 이용해서 풀어보자. 입력 범위가 90 이하로 제한돼 있어
90번째까지의 피보나치 수를 컴파일 시점에 미리 계산해서 저장해 두고, 런타임에는 값을 읽어서 출력해 주기만 하면 실행 시간을 아낄 수 있다.

먼저 나이브하게 재귀로 풀게 되면 O(2^n)이나 되는 무진장 많은 연산을 요구한다.

```rust
// 🐌 O(2^n)
fn fib(n: u64) -> u64 {
    match n {
        0 | 1 => n,
        n => fib(n - 1) + fib(n - 2),
    }
}
```

두 변수로 저글링을 하면 선형 시간까지 줄일 수 있다.

```rust
// 👌 O(n)
fn fib(n: u64) -> u64 {
    use std::mem;

    if n == 0 {
        return 0;
    }

    let mut a = 0;
    let mut b = 1;

    for _ in 1..n {
        // (a, b) = (b, a + b)라고 쓰면 좋겠지만 destructuring assignment는 아직 unstable이다.
        // rust-lang/rust#71126
        a = a + b;
        mem::swap(&mut a, &mut b);
    }

    b
}
```

더 빠르게 응답하고 싶다면 프로그램이 실행되자마자 90번째까지의 피보나치 수열을 계산해서 배열에 저장해두고, 그 배열을 읽어서 상수 시간에
응답할 수도 있다.

```rust
// 😤 O(1) 응답, O(n) 초기화, O(n) 저장 공간
fn fib(n: usize) -> Vec<u64> {
    let mut fib = vec![0; n + 1];
    fib[1] = 1;

    for i in 2..=n {
        fib[i] = fib[i - 1] + fib[i - 2];
    }

    fib
}

let fib = fib(90);
println!("{}", fib[n]);
```

컴파일 시점 함수 실행을 이용하면 90번째까지의 피보나치 수열을 컴파일 시점에 계산하고, 런타임에는 초기 실행 시간 없이 상수 시간에 응답할
수 있다.

```rust
// ✨ O(1) 응답, O(n) 컴파일 시간, O(n) 바이너리 사이즈
const N: usize = 90;

const FIB: [u64; N + 1] = {
    let mut fib = [0; N + 1];
    fib[1] = 1;

    let mut i = 2;
    while i <= N { // 아직 rust 상수 맥락에선 for loop를 쓸 수 없다. rust-lang/rfcs#2632
        fib[i] = fib[i - 1] + fib[i - 2];
        i += 1;
    }

    fib
};

println!("{}", FIB[n]);
```

아래처럼 피보나치 수열을 배열 리터럴로 적으면 컴파일도 빨라지고 좋지 않냐고 말할 수 있겠다. 피보나치 수열을 컴파일 시점 실행으로
구했을 때의 장점은 나중에 간단히 상수 `N` 값만 조절해서 피보나치 수열의 길이를 조절할 수 있다는 점이다. 이는 코드에 피보나치 수열 그
자체가 아닌 피보나치 수열을 구하는 방법을 적어두었기 때문에 가능한 것이다. 일반화를 시키자면, 코드로 실행의 결과가 아닌 의도를 기술하는
것이 유지보수에 이롭다고 할 수 있겠다.

```rust
// 🤔
const FIB: [u64; 91] = [
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,
    17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,
    5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296,
    433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025,
    20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162,
    591286729879, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842,
    10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994,
    190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657,
    2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221,
    23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088,
    259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931,
    1779979416004714189, 2880067194370816120
];
```

사실 90번째까지의 피보나치 수열을 계산하는 건 쉬운 문제라 런타임에 계산하는 것과 별 차이가 없을 것이다. 좀 더 시간이 많이 드는
경우에나 컴파일 시점 계산의 의의가 있을 것 같다. 바이너리가 커지고 컴파일이 오래 걸려도 상관없는 상황이라면 한 번 사용해 보자.

[1]: https://www.acmicpc.net/problem/2748
[2]: https://en.wikipedia.org/wiki/Compile-time_function_execution
