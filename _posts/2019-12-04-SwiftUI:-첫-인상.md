---
layout: post
title: "SwiftUI: 첫 인상"
date: 2019-12-08 18:00:00 +0900
categories: 
---

SwiftUI는 [WWDC 2019에서 발표]된 Apple의 사용자 인터페이스(UI) 프레임워크로,
iOS, watchOS, macOS, tvOS의 모든 Apple 플랫폼 앱의 개발에 사용할 수 있다.
SwiftUI는 **선언적인** UI 프레임워크라는 점에서 Vue, React와 비슷하다.
하지만 플랫폼의 제작자가 직접 만들었다는 점이 다르다.
Vue, React는 웹 표준이 아니지만 SwiftUI는 Swift다.

일반적인 프로그래밍 언어를 UI 선언에 알맞게 사용하기 위해서는 많은 문법 설탕이 필요하다.
React는 HTML이나 JavaScript만으로 UI를 잘 표현할 수 없다고 판단해서 JSX를 만들어냈고,
그래서 JSX를 처리하는 별도의 툴링이 필요하다. 반면 SwiftUI는 Swift의 일부이다.
한 회사에서 플랫폼, 언어, UI 프레임워크를 모두 만들기 때문에
Swift 언어를 만들 때 SwiftUI를 의식해서 설계한 것 같다.

이 글에서는 SwiftUI를 가능하게 한 Swift의 문법 설탕들을 살펴본다.

아래는 [SwiftUI 튜토리얼] 에서 가져온 예시 코드이다.

[WWDC 2019에서 발표]: https://developer.apple.com/videos/play/wwdc2019/204/
[SwiftUI 튜토리얼]: https://developer.apple.com/tutorials/swiftui/handling-user-input

```swift
import SwiftUI

struct LandmarkList: View {
  @State var showFavoritesOnly = true

  var body: some View {
    NavigationView {
      List {
        Toggle(isOn: $showFavoritesOnly) {
          Text("Favorites only")
        }

        ForEach(landmarkData) { landmark in
          if !self.showFavoritesOnly || landmark.isFavorite {
            NavigationLink(destination: LandmarkDetail(landmark: landmark)) {
              LandmarkRow(landmark: landmark)
            }
          }
        }
      }
      .navigationBarTitle(Text("Landmarks"))
    }
  }
}
```

## Property Wrapper: @State

제일 먼저 눈에 들어오는건 이 모든게 한 struct라는 점이다.
이 struct는 두 property를 가지고 있는데, 그건 바로 showFavoritesOnly, body이다.
그 다음엔 @State 가 눈에 띈다.

Swift에서 @의 역할은 나에게 처음부터 미스터리였다.
Xcode로 iOS앱을 개발하면, 이 버튼이 눌릴 때 어떤 코드가 실행될지 지정하기 위해
그 버튼을 코드 한 가운데로 ctrl-드래그해야 했는데, 그럼 그 코드 한 가운데에
이런 property가 추가되었다.

```swift
@IBOutlet weak var nameTextField: UITextField!
```

이런 작동 방식은 나한테 생소했고, Xcode가 내부 구현을 가리고 있는 것처럼 느껴졌다.
과연 [관련 Swift 기획안][SE-0258]를 찾아보니 SwiftUI를 지원하기 시작한 Swift 5.1 이전까지
@ attribute의 구현은 컴파일러에 하드코딩 돼 있던 모양이다.
그러니 작동방식이 모호하게 느껴질만 했지.

하지만 이 기획안에서는 일반 개발자도 @ 를 이용할 수 있도록 작동 방식을 표준화 하는걸 골자로 하고 있다.
요약하자면 property 앞에 @을 이용해 기능을 덧붙이는걸 property wrapper라고 부르고,
property wrapper는 아래와 같이 정의할 수 있다.

```swift
@propertyWrapper
struct TwelveOrLess {
    private var number = 0
    var wrappedValue: Int {
        get { return number }
        set { number = min(newValue, 12) }
    }
}
```

Property wrapper는 아래와 같이 사용할 수 있고

```swift
struct Rectangle {
  @TwelveOrLess var width: Int
}
```

property wrapper를 쓴 위의 코드는 쓰지 않은 아래의 코드와 똑같은 방식으로 작동한다.

```swift
struct Rectangle {
  private var _width = TwelveOrLess()

  var width: Int {
    get { return _width.wrappedValue }
    set { _width.wrappedValue = newValue }
  }
}
```

SwiftUI가 이렇게 state가 바뀔 때 UI를 업데이트하는 로직을 property wrapper
속에 숨겨두었기 때문에 개발자는 원하는 property를 선언하고 그 앞에 @State라고만 적어주면 된다.



[SE-0258]: https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md

## Opaque Type: some

+++WIP+++

## 클로저 문법 설탕

Swift는 함수의 마지막 인자가 클로저일 때 독특한 문법 설탕을 가지고 있다.

```swift
let numbers = [42, 17, 23, 7, 11, 5]

numbers.map({ (number) -> String in String(number) })
```

map(_:)처럼 closure를 마지막 인자로 받는 경우에

```swift
numbers.map { (number) -> String in String(number) }
```

이렇게 함수 호출 괄호 () 를 생략할 수 있다.

함수 인자가 여러 개인 경우에는

```swift
func someFunctionThatTakesAClosure(a: Int, b: String, closure: () -> Void) {
  // function body
}

someFunctionThatTakesAClosure(a: 0, b: "", closure: {
  // closure body
})
```

위의 세번째 인자 closure를 아래와 같은 문법으로 호출할 수 있다.

```swift
someFunctionThatTakesAClosure(a: 0, b: "") {
  // closure body
}
```

이 마지막 인자인 클로저 설탕은 SwiftUI에서 아래와 같이 사용된다. 아래의 두 코드는 같은 코드에
설탕을 친 버전(위)과 오리지널 버전(아래)이다.

```swift
ForEach(landmarkData) { landmark in
  if !self.showFavoritesOnly || landmark.isFavorite {
    NavigationLink(destination: LandmarkDetail(landmark: landmark)) {
      LandmarkRow(landmark: landmark)
    }
  }
}
```

```swift
ForEach(landmarkData, content: { landmark in
  if !self.showFavoritesOnly || landmark.isFavorite {
    NavigationLink(destination: LandmarkDetail(landmark: landmark)) {
      LandmarkRow(landmark: landmark)
    }
  })
}
```

이 결과 SwiftUI는 좀 더 예쁜 UI 반복선언이 가능하다.

## Builder
