---
layout: post
title: "SwiftUI: 첫 인상"
date: 2019-12-08 18:00:00 +0900
categories: 
---

SwiftUI는 [WWDC 2019에서 발표]된 Apple의 선언적인 사용자 인터페이스(UI) 프레임워크로,
iOS, macOS, watchOS, tvOS의 모든 Apple 플랫폼 앱의 개발에 사용할 수 있다.

아래는 [SwiftUI 튜토리얼]에서 가져온 코드이다.

[WWDC 2019에서 발표]: https://developer.apple.com/videos/play/wwdc2019/204/
[SwiftUI 튜토리얼]: https://developer.apple.com/tutorials/swiftui/handling-user-input

```swift
import SwiftUI

struct LandmarkList: View {
  @State var showFavoritesOnly = true

  var body: some View {
    NavigationView {
      List {
        Toggle(isOn: $showFavoritesOnly) {
          Text("Favorites only")
        }

        ForEach(landmarkData) { landmark in
          if !self.showFavoritesOnly || landmark.isFavorite {
            NavigationLink(destination: LandmarkDetail(landmark: landmark)) {
              LandmarkRow(landmark: landmark)
            }
          }
        }
      }
      .navigationBarTitle(Text("Landmarks"))
    }
  }
}
```

처음 SwiftUI 코드를 보고 놀란 점은 이 코드가 여전히 `.swift` 파일로 작성되었다는 점이었다.
그러니까, 저 코드는 모두 Swift 였다.

뒤늦게 알게 된 사실은, Apple이 이런 간결한 UI 선언을 위해
Swift에 많은 기능과 문법 설탕을 추가했다는 것이다.


## 속성 싸개: @State

제일 먼저 눈에 들어오는건 컴퍼넌트가 구조체라는 점이다.
이 구조체는 두 속성(property)을 가지고 있는데, 바로 `showFavoritesOnly`와 `body`이다.
그 다음엔 `showFavoritesOnly` 앞에 있는 @State가 눈에 띈다.

Swift에서 `@`의 역할은 나에게 처음부터 미스터리였다.
Xcode로 iOS앱을 개발하면, 이 버튼이 눌릴 때 어떤 코드가 실행될지 지정하기 위해
그 버튼을 코드 한 가운데로 ctrl-드래그해야 했는데, 그러면 그 코드 한 가운데에
이런 속성이 추가되었다.

```swift
@IBOutlet weak var nameTextField: UITextField!
```

이런 작동 방식은 나한테 생소했고, Xcode가 내부 구현을 가리고 있는 것처럼 느껴졌다.
도대체 `@IBOutlet`의 구현은 어디에 숨어있는 것이며, 나도 다른 `@`들을 정의할 수는 없는 것인지 궁금했다.
과연 [관련 Swift 발전 기획안][SE-0258]를 찾아보니 Swift 5.1 이전까지
`@`의 구현이 컴파일러에 하드코딩 돼 있던 모양이다. 그러니 작동방식이 모호하게 느껴질만 했지.

이 기획안은 일반 개발자도 `@` 를 이용할 수 있도록 작동 방식을 표준화 하는걸 골자로 하고 있다.
요컨대 `@State`처럼 속성 앞에 `@`을 이용해 기능을 덧붙이는걸 속성 싸개(property wrapper)라고 부르고,
개발자들은 속성을 저장하는 로직과 속성 접근을 제어하는 로직을 재활용하기 위해 속성 싸개를 사용할 수 있다.

SwiftUI에서는 `@State`, `@Binding`, `@EnvironmentObject`의 속성 싸개를 이용해서 상태 관리를 하는데,
React의 Redux같은 장황한 솔루션은 두말할 것도 없고, Vuex보다도 깔끔한 것 같다.
무엇보다 이 모든게 컴파일러에 하드코딩된 새로운 개념이 아니라
사용자 정의 가능한 Swift 문법의 일부라는게 특히 마음에 든다.

[SE-0258]: https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md


## 읽기 전용 계산된 속성

Swift에서는 계산된 속성을 선언할 수 있다.

```swift
struct Rectangle {
  var width = 0.0
  var height = 0.0
  
  var area: Double {
    get {
      return width * height
    }
  }
}

let r = Rectangle(width: 2, height: 3)

// r의 면적은 6.0입니다.
print("r의 면적은 \(r.area)입니다.")
```

계산된 속성의 매기개(setter)가 없다면 얻개(getter)의 `get` 키워드를 생략할 수 있다.
<!-- setter 매기개 getter 얻개.. -->
```swift
struct Rectangle {
  //
  var area: Double {
    return width * height
  }
}
```

더 나아가 Swift 5.1 에서는 [return을 생략할 수 있는 문법이 추가][SE-0255]되었다.

```swift
struct Rectangle {
  //
  var area: Double { width * height }
}
```

위 `LandmarkList` 뷰의 `body` 프로퍼티는 이 문법 설탕을 이용해서 `return` 키워드 없는
아래와 같은 문법을 가질 수 있는 것이다. 

```swift
// ✅ get, return 생략

var body: some View {
  NavigationView {
  // 자세한 구현
  }
}
```

```swift
// ⛔️ 생략하지 않음

var body: some View {
  get {
    return NavigationView {
      // 자세한 구현
    }
  }
}
```

[SE-0255]: https://github.com/apple/swift-evolution/blob/master/proposals/0255-omit-return.md

## 불투명한 타입: some

`body`의 타입에 `some`이라는 처음보는 키워드가 붙어 있다.
찾아보니 역시 [Swift 5.1에 새로 추가][SE-0244]된 개념이다.

짧게 설명하기 어려운 타입에 관한 이야기가 필요해서 이 포스트에선 생략하겠다.
하지만 `some` 키워드를 이해하지 못해도 SwiftUI를 당장 사용하는 데에 큰 지장은 없어 보인다.

[SE-0244]: https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md

## 클로저 문법 설탕

Swift는 함수의 마지막 인자가 클로저일 때 독특한 문법 설탕을 가지고 있다.

```swift
let numbers = [42, 17, 23, 7, 11, 5]

numbers.map({ (number) -> String in String(number) })
```

map(_:)처럼 closure를 마지막 인자로 받는 경우에

```swift
numbers.map { (number) -> String in String(number) }
```

이렇게 함수 호출 괄호 () 를 생략할 수 있다.

함수 인자가 여러 개인 경우에는

```swift
func someFunctionThatTakesAClosure(a: Int, b: String, closure: () -> Void) {
  // function body
}

someFunctionThatTakesAClosure(a: 0, b: "", closure: {
  // closure body
})
```

위의 세번째 인자 closure를 아래와 같은 문법으로 호출할 수 있다.

```swift
someFunctionThatTakesAClosure(a: 0, b: "") {
  // closure body
}
```

이 클로저 마지막 인자인 위한 문법 설탕은 SwiftUI에서 아래와 같이 사용된다.
아래의 두 코드는 같은 의미의 코드이다.

```swift
// ✅ 문법 설탕 사용

ForEach(landmarkData) { landmark in
  if !self.showFavoritesOnly || landmark.isFavorite {
    NavigationLink(destination: LandmarkDetail(landmark: landmark)) {
      LandmarkRow(landmark: landmark)
    }
  }
}
```

```swift
// ⛔️ 문법 설탕 사용 안 함

ForEach(landmarkData, content: { landmark in
  if !self.showFavoritesOnly || landmark.isFavorite {
    NavigationLink(destination: LandmarkDetail(landmark: landmark)) {
      LandmarkRow(landmark: landmark)
    }
  })
}
```

이 결과 SwiftUI는 좀 더 간결한 UI 반복선언이 가능하다.

## 용어
- 매기개: setter. `매기다` + `-개`. 일반적으로 설정자로 번역된다.
- 얻개: getter. `얻다` + `-개`. 일반적으로 획득자 혹은 접근자로 번역된다.




<!-- 🔥🔥🔥 편집 방향 🔥🔥🔥 -->
<!-- 
소개글이 아니라 내 첫 인상이란 느낌으로!
swift에 ~가 있다
대신
??이 문법은 도대체 어떻게 가능한 것일까?
이런 접근으로 가자
 -->
