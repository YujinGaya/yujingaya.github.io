---
layout: post
title:  "호환되는 다국어 프로그래밍 언어"
date:   2020-10-03 17:00:00 +0900
---

프로그래밍 언어를 새로 배우는 사람에겐 `for`, `if` 같은 영어로 된 키워드가 낯설고 어렵게 느껴진다. 문제는 키워드만 익히면 되는게
아니란거다. 파이썬 내장 수학 모듈에는 `ceil`, `floor`, `gcd`라는 이름의 함수들이 있다. 만약 이 함수가 `올림`, `내림`,
`최대공약수` 라는 이름이었다면 수 많은 개발자가 최대공약수를 구하는 함수를 직접 짤 시간을 아껴서 아이스크림을 하나 더 먹을 수 있지
않았을까?

당연하지만 자국어로 프로그래밍 언어를 만들어보겠다는 시도는 끊임없이 있었다. [한글코딩](http://한글코딩.org/언어.html) 이라는
프로젝트에서는 JavaScript가 유니코드 식별자를 지원한다는걸 이용해서 아래와 같이 한국어로 코드를 작성하도록 추천하고 있다. 

```javascript
// 연비측정법: 가득 주유하고 누적 주행거리(Km)를 기록해 둔 다음,
// 기름을 적어도 절반 이상 쓸 만큼 주행하고 나서 다시 누적 주행거리를 기록한다.
// 그리고 다시 가득 주유하며 들어간 기름의 양(L)을 확인한다.
// 마지막으로 두 누적 주행거리의 차이를 가득 주유한 양으로 나눈다.

function 연비(주유량, 누적주행1, 누적주행2) {
    var 주행거리 = Math.abs(누적주행1 - 누적주행2);
    return 주행거리 / 주유량;
}

console.log( 연비(55, 59000, 58230) ); // => 14
```

한국어 식별자를 이용하는 방법은 키워드가 여전히 영어라는 한계가 있다. 계속 한영 전환을 해 줘야한다는 점도 거슬리고 세종대왕이 알파벳
옆에 붙어있을 때 예뻐 보이라고 한글을 네모낳게 만든게 아니란 사실이 신경쓰인다. 그냥, 안 예쁘다.

언어를 통째로 한국어로 만든 경우도 여럿 있다. 최근에는 [누리](https://github.com/suhdonghwi/nuri) 언어가 이목을
끌었다.

```누리
10을 5로 나누고 출력하다                           # print(divide(10, 5))에 해당

함수 [목록]의 합계:                               # `~의 합계` 함수가 인자로 `목록`을 받음
  만약 [목록] == {} 이라면 0                      # if 브랜치는 재귀 종료 조건
  아니라면 [목록]의 첫번째 + ([목록]의 나머지)의 합계    # else 브랜치에서 재귀 호출
```

혁신적인 가독성 향상이 머리부터 발끝까지 느껴진다. 이제 더 이상 두 선분이 평행한지 알려주는 함수의 이름을 지을 때 parallel의
어디가 r이고 어디가 l이고 어디가 a고 어디가 e인지 사전을 찾아볼 필요가 없다. 그냥 `평행한가`로 짓자.
(아무래도 어미는 컨벤션을 정리할 필요가 있어 보인다.)

하지만 누리도 한계가 명확하다. 한국어를 모르면 이 코드를 가져다 쓸 수가 없다. 코드를 재활용 할 수 없다.
코딩 꼬꼬마는 딜레마에 빠진다. 익숙해지긴 어렵지만 일단 배우고 나면 전세계 수 많은 개발자가 짜놓은 라이브러리에 접근할 수 있는 영어
프로그래밍 언어를 배울 것인가, 아니면 지금 보기엔 쉬워 보이지만 미래가 없다고들 하는 한국어 프로그래밍 언어를 배울 것인가. 나라면
전자를 택할 것 같다.

이 상황에서 촘스키 옹의 **보편문법**이란 개념을 살짝 부어보자. 촘스키는 모든 언어가 보편문법이라고 부르는 보편적인 문법을
갖추고 있고, 우리의 마음은 그 언어로 개념을 이해하기 때문에 우리가 다른 언어를 쉽게 배울 수 있댔다. 어디서 많이 들어본 얘기 아닌가?
프로그래밍 언어는 다양한 문법을 갖추고 있지만 LLVM은 LLVM IR의 형태로 그 다양한 언어를 한 언어인양 이해한다. 다국어 프로그래밍
언어도 이 아이디어를 받아들여서 구체적인 문법은 개별 언어마다 다르지만, 특정 시점에 한 IR (Intermediate Representation, 
중간 표현)로 표현될 수 있게 설계할 수 있을 것이다.

키워드나 문법은 컴파일러에서 번역할 수 있더라도 식별자는 라이브러리 작성자가 번역을 제공해야할 것이다. 이 부분은 TypeScript가 기존
JavaScript 라이브러리의 타입을 차후에 d.ts 확장자의 별도 파일로 선언할 수 있었던 것 처럼, 함수 시그니처를 번역해놓은 별도 포맷을
정의해서 해결할 수 있을 것 같다. 예를 들자면 이런 식이다. (확장자는 임의로 .he로 설정했다. 헤헤의 헤다)

```
project/
└── src/
    ├── linked_list.he
    └── linked_list.ko_kr.he
```

```rust
// linked_list.he
impl LinkedList {
  fn contains(&self, x: T) -> bool {
    // 실제 구현
  }

  fn len(&self) -> usize {
    // 실제 구현
  }
}
```

```
// linked_list.ko_kr.he
LinkedList {
  fn contains(&self, x:T) -> bool;
  [나]는 [갑]을 포함한다 -> 진리값;

  fn len(&self) -> usize;
  [나]의 길이 -> 양수;
}
```


// STATUS: DRAFT!
